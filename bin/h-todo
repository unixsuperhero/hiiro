#!/usr/bin/env ruby

require 'hiiro'

tm = Hiiro::TodoManager.new

Hiiro.run(*ARGV, todo_file: tm.todo_file) do
  add_subcmd(:ls) do |*ls_args|
    show_all = ls_args.delete('-a') || ls_args.delete('--all')
    status_filter = nil
    tag_filter = nil
    task_filter = nil

    while ls_args.any?
      arg = ls_args.shift
      case arg
      when '-s', '--status'
        status_filter = ls_args.shift
      when '-t', '--tag'
        tag_filter = ls_args.shift
      when '--task'
        task_filter = ls_args.shift
      end
    end

    items = if status_filter
      tm.filter_by_status(*status_filter.split(','))
    elsif tag_filter
      tm.filter_by_tag(tag_filter)
    elsif task_filter
      tm.filter_by_task(task_filter)
    elsif show_all
      tm.all
    else
      tm.active
    end

    if items.empty?
      puts "No todo items found."
    else
      puts tm.list(items)
    end
  end

  add_subcmd(:list) do |*list_args|
    run_subcmd(:ls, *list_args)
  end

  add_subcmd(:add) do |*add_args|
    if add_args.empty?
      new_items = tm.edit_items
      if new_items.empty?
        puts "No items added."
        next
      end

      tm.add_items(new_items)
      if new_items.length == 1
        puts "Added: #{tm.format_item(new_items.first)}"
      else
        puts "Added #{new_items.length} items:"
        new_items.each { |item| puts "  #{tm.format_item(item)}" }
      end
      next
    end

    tags = nil
    text_parts = []

    while add_args.any?
      arg = add_args.shift
      case arg
      when '-t', '--tags'
        tags = add_args.shift
      else
        text_parts << arg
      end
    end

    text = text_parts.join(' ')
    if text.empty?
      puts "Usage: h todo add <text> [-t tags]"
      exit 1
    end

    item = tm.add(text, tags: tags)
    puts "Added: #{tm.format_item(item)}"
  end

  add_subcmd(:rm) do |*rm_args|
    id_or_index = rm_args.shift
    if id_or_index.nil?
      puts "Usage: h todo rm <id>"
      exit 1
    end

    item = tm.remove(id_or_index)
    if item
      puts "Removed: #{item.text}"
    else
      puts "Item not found: #{id_or_index}"
      exit 1
    end
  end

  add_subcmd(:remove) do |*remove_args|
    run_subcmd(:rm, *remove_args)
  end

  add_subcmd(:change) do |*change_args|
    id_or_index = change_args.shift
    if id_or_index.nil?
      puts "Usage: h todo change <id> [--text TEXT] [--tags TAGS] [--status STATUS]"
      exit 1
    end

    text = nil
    tags = nil
    status = nil

    while change_args.any?
      arg = change_args.shift
      case arg
      when '--text'
        text = change_args.shift
      when '--tags', '-t'
        tags = change_args.shift
      when '--status', '-s'
        status = change_args.shift
      else
        text ||= ''
        text = [text, arg, *change_args].join(' ').strip
        break
      end
    end

    item = tm.change(id_or_index, text: text, tags: tags, status: status)
    if item
      puts "Updated: #{tm.format_item(item)}"
    else
      puts "Item not found: #{id_or_index}"
      exit 1
    end
  end

  add_subcmd(:start) do |*start_args|
    id_or_index = start_args.shift
    if id_or_index.nil?
      puts "Usage: h todo start <id>"
      exit 1
    end

    item = tm.start(id_or_index)
    if item
      puts "Started: #{tm.format_item(item)}"
    else
      puts "Item not found: #{id_or_index}"
      exit 1
    end
  end

  add_subcmd(:done) do |*done_args|
    id_or_index = done_args.shift
    if id_or_index.nil?
      puts "Usage: h todo done <id>"
      exit 1
    end

    item = tm.done(id_or_index)
    if item
      puts "Done: #{tm.format_item(item)}"
    else
      puts "Item not found: #{id_or_index}"
      exit 1
    end
  end

  add_subcmd(:skip) do |*skip_args|
    id_or_index = skip_args.shift
    if id_or_index.nil?
      puts "Usage: h todo skip <id>"
      exit 1
    end

    item = tm.skip(id_or_index)
    if item
      puts "Skipped: #{tm.format_item(item)}"
    else
      puts "Item not found: #{id_or_index}"
      exit 1
    end
  end

  add_subcmd(:reset) do |*reset_args|
    id_or_index = reset_args.shift
    if id_or_index.nil?
      puts "Usage: h todo reset <id>"
      exit 1
    end

    item = tm.reset(id_or_index)
    if item
      puts "Reset: #{tm.format_item(item)}"
    else
      puts "Item not found: #{id_or_index}"
      exit 1
    end
  end

  add_subcmd(:search) do |*search_args|
    query = search_args.join(' ')
    if query.empty?
      puts "Usage: h todo search <query>"
      exit 1
    end

    items = tm.search(query)
    if items.empty?
      puts "No items matching: #{query}"
    else
      puts tm.list(items)
    end
  end

  add_subcmd(:path) do |*args|
    print tm.todo_file
  end

  add_subcmd(:editall) do |*args|
    editor = ENV['EDITOR'] || 'safe_nvim' || 'nvim'
    system(editor, tm.todo_file)
  end

  add_subcmd(:help) do |*args|
    puts <<~HELP
      Usage: h todo <command> [args]

      Commands:
        ls, list              List todo items (active by default)
          -a, --all           Show all items including done/skip
          -s, --status STATUS Filter by status (not_started,started,done,skip)
          -t, --tag TAG       Filter by tag
          --task TASK         Filter by task name

        add [text] [-t tags]  Add todo item(s)
                              With no args, opens editor for YAML input

        rm, remove <id>       Remove a todo item

        change <id>           Modify a todo item
          --text TEXT         New text
          --tags TAGS         New tags
          --status STATUS     New status

        start <id>            Mark item as started
        done <id>             Mark item as done
        skip <id>             Mark item as skipped
        reset <id>            Reset item to not_started

        search <query>        Search items by text, tags, or task

        path                  Print path to todo.yml
        editall               Open todo.yml in editor

      Item IDs:
        Items are identified by a permanent numeric ID (1, 2, 3, ...).
        IDs are never reused, even after items are deleted.

      Status icons:
        [ ] not_started
        [>] started
        [x] done
        [-] skip
    HELP
  end
end
