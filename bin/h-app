#!/usr/bin/env ruby

require 'yaml'
require 'pathname'
require 'hiiro'

APPS_FILE = File.join(Dir.home, '.config', 'hiiro', 'apps.yml')

def load_apps
  return {} unless File.exist?(APPS_FILE)
  YAML.safe_load_file(APPS_FILE) || {}
end

def git_root
  root = `git rev-parse --show-toplevel 2>/dev/null`.strip
  root.empty? ? nil : root
end

def task_root
  # Fall back to current task's tree path if not in a git repo
  env = Environment.current rescue nil
  return nil unless env

  task = env.task
  return nil unless task

  tree = env.find_tree(task.tree_name)
  tree&.path
end

def resolve_app_path(app_relative_path)
  root = git_root || task_root
  return nil unless root

  File.join(root, app_relative_path)
end

def relative_cd_path(target_path)
  pwd = Pathname.new(Dir.pwd)
  target = Pathname.new(target_path)
  target.relative_path_from(pwd).to_s
end

def send_cd(path)
  pane = ENV['TMUX_PANE']
  if pane
    system('tmux', 'send-keys', '-t', pane, "cd #{path}\n")
  else
    system('tmux', 'send-keys', "cd #{path}\n")
  end
end

Hiiro.run(*ARGV, plugins: [:Tasks]) {
  add_subcmd(:config) {
    editor = ENV['EDITOR'] || 'nvim'
    system(editor, APPS_FILE)
  }

  add_subcmd(:cd) { |app_name=nil|
    root = git_root || task_root

    unless root
      puts "Not in a git repo or task - cannot resolve path"
      next
    end

    if app_name.nil? || app_name.empty?
      send_cd(relative_cd_path(root))
      next
    end

    apps = load_apps
    match = apps.find { |name, _| name.start_with?(app_name) }

    if match
      name, app_relative_path = match
      target = File.join(root, app_relative_path)
      send_cd(relative_cd_path(target))
    else
      puts "App '#{app_name}' not found"
      puts
      puts "Available apps:"
      apps.each { |name, path| puts format("  %-20s => %s", name, path) }
    end
  }

  add_subcmd(:ls) {
    apps = load_apps

    if apps.empty?
      puts "No apps configured."
      puts "Create #{APPS_FILE} with format:"
      puts "  app_name: /path/to/app"
    else
      puts "Configured apps:"
      puts
      apps.each { |name, path| puts format("  %-20s => %s", name, path) }
    end
  }

  add_subcmd(:path) { |app_name=nil|
    root = git_root || task_root

    unless root
      puts "Not in a git repo or task - cannot resolve path"
      next
    end

    if app_name.nil? || app_name.empty?
      puts relative_cd_path(root)
      next
    end

    apps = load_apps
    match = apps.find { |name, _| name.start_with?(app_name) }

    if match
      name, app_relative_path = match
      target = File.join(root, app_relative_path)
      puts relative_cd_path(target)
    else
      puts "App '#{app_name}' not found"
    end
  }

  add_subcmd(:abspath) { |app_name=nil|
    root = git_root || task_root

    unless root
      puts "Not in a git repo or task - cannot resolve path"
      next
    end

    if app_name.nil? || app_name.empty?
      puts root
      next
    end

    apps = load_apps
    match = apps.find { |name, _| name.start_with?(app_name) }

    if match
      name, app_relative_path = match
      puts File.join(root, app_relative_path)
    else
      puts "App '#{app_name}' not found"
    end
  }
}
