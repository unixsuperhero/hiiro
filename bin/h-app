#!/usr/bin/env ruby

require 'yaml'
require 'pathname'
require 'hiiro'

APPS_FILE = File.join(Dir.home, '.config', 'hiiro', 'apps.yml')

def load_apps
  return {} unless File.exist?(APPS_FILE)
  YAML.safe_load_file(APPS_FILE) || {}
end

def save_apps(apps)
  File.write(APPS_FILE, apps.to_yaml)
end

def task_root
  # Fall back to current task's tree path if not in a git repo
  env = Environment.current rescue nil
  return nil unless env

  task = env.task
  return nil unless task

  tree = env.find_tree(task.tree_name)
  tree&.path
end


def relative_cd_path(target_path)
  pwd = Pathname.new(Dir.pwd)
  target = Pathname.new(target_path)
  target.relative_path_from(pwd).to_s
end

def send_cd(path)
  pane = ENV['TMUX_PANE']
  if pane
    system('tmux', 'send-keys', '-t', pane, "cd #{path}\n")
  else
    system('tmux', 'send-keys', "cd #{path}\n")
  end
end

Hiiro.run(*ARGV, plugins: [:Tasks]) {
  add_subcmd(:config) {
    editor = ENV['EDITOR'] || 'nvim'
    system(editor, APPS_FILE)
  }

  add_subcmd(:cd) { |app_name=nil|
    root = git.root || task_root

    unless root
      puts "Not in a git repo or task - cannot resolve path"
      next
    end

    if app_name.nil? || app_name.empty?
      send_cd(relative_cd_path(root))
      next
    end

    apps = load_apps
    match = Hiiro::PrefixMatcher.find(apps, app_name) { |name, _| name }

    if match
      name, app_relative_path = match
      target = File.join(root, app_relative_path)
      send_cd(relative_cd_path(target))
    else
      puts "App '#{app_name}' not found"
      puts
      puts "Available apps:"
      apps.each { |name, path| puts format("  %-20s => %s", name, path) }
    end
  }

  add_subcmd(:ls) {
    apps = load_apps

    if apps.empty?
      puts "No apps configured."
      puts "Create #{APPS_FILE} with format:"
      puts "  app_name: /path/to/app"
    else
      puts "Configured apps:"
      puts
      apps.each { |name, path| puts format("  %-20s => %s", name, path) }
    end
  }

  add_subcmd(:path) { |app_name=nil|
    root = git.root || task_root

    unless root
      puts "Not in a git repo or task - cannot resolve path"
      next
    end

    if app_name.nil? || app_name.empty?
      puts relative_cd_path(root)
      next
    end

    apps = load_apps
    match = Hiiro::PrefixMatcher.find(apps, app_name) { |name, _| name }

    if match
      name, app_relative_path = match
      target = File.join(root, app_relative_path)
      puts relative_cd_path(target)
    else
      puts "App '#{app_name}' not found"
    end
  }

  add_subcmd(:abspath) { |app_name=nil|
    root = git.root || task_root

    unless root
      puts "Not in a git repo or task - cannot resolve path"
      next
    end

    if app_name.nil? || app_name.empty?
      puts root
      next
    end

    apps = load_apps
    match = Hiiro::PrefixMatcher.find(apps, app_name) { |name, _| name }

    if match
      name, app_relative_path = match
      puts File.join(root, app_relative_path)
    else
      puts "App '#{app_name}' not found"
    end
  }

  add_subcmd(:add) { |app_name=nil, relative_path=nil|
    if app_name.nil? || app_name.empty?
      puts "Usage: h app add <app_name> <relative_path_from_root>"
      next
    end

    if relative_path.nil? || relative_path.empty?
      puts "Usage: h app add <app_name> <relative_path_from_root>"
      next
    end

    apps = load_apps

    if apps.key?(app_name)
      puts "App '#{app_name}' already exists with path: #{apps[app_name]}"
      puts "Remove it first with: h app rm #{app_name}"
      next
    end

    apps[app_name] = relative_path
    save_apps(apps)
    puts "Added app '#{app_name}' => #{relative_path}"
  }

  add_subcmd(:rm) { |app_name=nil|
    if app_name.nil? || app_name.empty?
      puts "Usage: h app rm <app_name>"
      next
    end

    apps = load_apps

    unless apps.key?(app_name)
      puts "App '#{app_name}' not found"
      puts
      puts "Available apps:"
      apps.each { |name, path| puts format("  %-20s => %s", name, path) }
      next
    end

    removed_path = apps.delete(app_name)
    save_apps(apps)
    puts "Removed app '#{app_name}' (was: #{removed_path})"
  }

  add_subcmd(:remove) { |app_name=nil|
    if app_name.nil? || app_name.empty?
      puts "Usage: h app remove <app_name>"
      next
    end

    apps = load_apps

    unless apps.key?(app_name)
      puts "App '#{app_name}' not found"
      puts
      puts "Available apps:"
      apps.each { |name, path| puts format("  %-20s => %s", name, path) }
      next
    end

    removed_path = apps.delete(app_name)
    save_apps(apps)
    puts "Removed app '#{app_name}' (was: #{removed_path})"
  }
}
