#!/usr/bin/env ruby

require "hiiro"
require "time"
require "fileutils"
require "yaml"
require "json"
require "tempfile"

Hiiro.load_env

class PRManager
  attr_reader :hiiro

  def initialize(hiiro)
    @hiiro = hiiro
  end

  def save(pr_number = nil)
    pr_info = fetch_pr_info(pr_number)
    unless pr_info
      puts "ERROR: Could not find PR"
      puts "Make sure you have the gh CLI installed and authenticated."
      return false
    end

    entry = build_entry(pr_info)
    unless entry[:task]
      puts "WARNING: Not in a task session, saving without task info"
    end

    data = load_data
    data['prs'] ||= []

    # Check if this PR is already recorded for this task
    existing = data['prs'].find do |p|
      p['number'] == pr_info['number'] && p['task'] == entry[:task]
    end

    if existing
      # Update existing entry
      existing.merge!(entry.transform_keys(&:to_s))
      existing['updated_at'] = Time.now.iso8601
      puts "Updated PR ##{pr_info['number']} for task '#{entry[:task]}'"
    else
      # Add new entry
      data['prs'] << entry.transform_keys(&:to_s).merge('created_at' => Time.now.iso8601)
      puts "Saved PR ##{pr_info['number']} for task '#{entry[:task]}'"
    end

    save_data(data)
    show_entry(entry)
    true
  end

  def current
    pr_info = fetch_pr_info
    unless pr_info
      puts "No PR found for current branch."
      puts "Create one with 'gh pr create' or specify a PR number."
      return false
    end

    entry = build_entry(pr_info)
    puts "Current PR info:"
    puts
    show_entry(entry)
  end

  def open(pr_number = nil)
    if pr_number
      system('gh', 'pr', 'view', pr_number.to_s, '--web')
    else
      system('gh', 'pr', 'view', '--web')
    end
  end

  def view(pr_number = nil)
    if pr_number
      system('gh', 'pr', 'view', pr_number.to_s)
    else
      system('gh', 'pr', 'view')
    end
  end

  private

  def fetch_pr_info(pr_number = nil)
    cmd = if pr_number
      ['gh', 'pr', 'view', pr_number.to_s, '--json', 'number,title,url,headRefName,state']
    else
      ['gh', 'pr', 'view', '--json', 'number,title,url,headRefName,state']
    end

    output = `#{cmd.join(' ')} 2>/dev/null`
    return nil if output.empty?

    JSON.parse(output)
  rescue JSON::ParserError
    nil
  end

  def build_entry(pr_info)
    current_task = Environment.current.task
    tmux_info = capture_tmux_info

    {
      number: pr_info['number'],
      title: pr_info['title'],
      url: pr_info['url'],
      branch: pr_info['headRefName'],
      state: pr_info['state'],
      worktree: current_task&.tree_name,
      task: current_task&.name,
      tmux: tmux_info
    }
  end

  def capture_tmux_info
    return nil unless ENV['TMUX']

    {
      'session' => `tmux display-message -p '#S'`.strip,
      'window' => `tmux display-message -p '#W'`.strip,
      'pane' => ENV['TMUX_PANE']
    }
  end

  def format_entry(entry, num)
    lines = []
    lines << "#{num}. PR ##{entry['number']}: #{entry['title']}"
    lines << "   Branch: #{entry['branch']}"
    lines << "   State: #{entry['state']}"
    lines << "   Task: #{entry['task'] || '(none)'}"
    lines << "   Worktree: #{entry['worktree'] || '(none)'}"
    if entry['tmux']
      lines << "   Tmux: #{entry['tmux']['session']}/#{entry['tmux']['window']}"
    end
    lines << "   Created: #{entry['created_at']}"
    lines << "   URL: #{entry['url']}"
    lines.join("\n")
  end

  def show_entry(entry)
    puts "  PR: ##{entry[:number]}"
    puts "  Title: #{entry[:title]}"
    puts "  Branch: #{entry[:branch]}"
    puts "  State: #{entry[:state]}"
    puts "  URL: #{entry[:url]}"
    puts "  Task: #{entry[:task] || '(none)'}"
    puts "  Worktree: #{entry[:worktree] || '(none)'}"
    if entry[:tmux]
      puts "  Tmux session: #{entry[:tmux]['session']}"
      puts "  Tmux window: #{entry[:tmux]['window']}"
      puts "  Tmux pane: #{entry[:tmux]['pane']}"
    end
  end

  def data_file
    File.join(Dir.home, '.config', 'hiiro', 'prs.yml')
  end

  def load_data
    return {} unless File.exist?(data_file)
    YAML.safe_load_file(data_file) || {}
  end

  def save_data(data)
    FileUtils.mkdir_p(File.dirname(data_file))
    File.write(data_file, YAML.dump(data))
  end
end

class PinnedPRManager
  PINNED_FILE = File.join(Dir.home, '.config/hiiro/pinned_prs.yml')

  def initialize
    ensure_file
  end

  def ensure_file
    dir = File.dirname(PINNED_FILE)
    FileUtils.mkdir_p(dir) unless Dir.exist?(dir)
    File.write(PINNED_FILE, [].to_yaml) unless File.exist?(PINNED_FILE)
  end

  def load_pinned
    ensure_file
    YAML.load_file(PINNED_FILE) || []
  end

  def save_pinned(prs)
    ensure_file
    File.write(PINNED_FILE, prs.to_yaml)
  end

  def pin(pr_info)
    pinned = load_pinned
    existing = pinned.find { |p| p['number'] == pr_info['number'] }

    if existing
      existing.merge!(pr_info)
      existing['updated_at'] = Time.now.iso8601
    else
      pr_info['pinned_at'] = Time.now.iso8601
      pinned << pr_info
    end

    save_pinned(pinned)
    pr_info
  end

  def unpin(pr_number)
    pinned = load_pinned
    removed = pinned.reject! { |p| p['number'].to_s == pr_number.to_s }
    save_pinned(pinned)
    removed
  end

  def pinned?(pr_number)
    load_pinned.any? { |p| p['number'].to_s == pr_number.to_s }
  end

  def fetch_pr_info(pr_number)
    fields = 'number,title,url,headRefName,state,statusCheckRollup,reviewDecision,reviews,isDraft,mergeable'
    output = `gh pr view #{pr_number} --json #{fields} 2>/dev/null`.strip
    return nil if output.empty?
    JSON.parse(output)
  rescue JSON::ParserError
    nil
  end

  def fetch_current_branch_pr
    fields = 'number,title,url,headRefName,state'
    output = `gh pr view --json #{fields} 2>/dev/null`.strip
    return nil if output.empty?
    JSON.parse(output)
  rescue JSON::ParserError
    nil
  end

  def fetch_my_prs
    output = `gh pr list --author @me --state open --json number,title,headRefName,url 2>/dev/null`.strip
    return [] if output.empty?
    JSON.parse(output) rescue []
  end

  def fetch_my_and_assigned_prs
    authored = `gh pr list --author @me --state open --json number,title,headRefName,url 2>/dev/null`.strip
    assigned = `gh pr list --assignee @me --state open --json number,title,headRefName,url 2>/dev/null`.strip

    authored_prs = authored.empty? ? [] : (JSON.parse(authored) rescue [])
    assigned_prs = assigned.empty? ? [] : (JSON.parse(assigned) rescue [])

    # Dedupe by PR number
    (authored_prs + assigned_prs).uniq { |pr| pr['number'] }
  end

  def needs_refresh?(pr, force: false)
    return true if force
    return true unless pr['last_checked']

    last_check_time = Time.parse(pr['last_checked']) rescue nil
    return true unless last_check_time

    # Refresh if last check was more than 2 minutes ago
    (Time.now - last_check_time) > 120


  def batch_fetch_pr_info(pr_numbers)
    return {} if pr_numbers.empty?

    # Build GraphQL query to fetch multiple PRs at once
    pr_queries = pr_numbers.map.with_index do |num, idx|
      <<~GRAPHQL.strip
        pr#{idx}: pullRequest(number: #{num}) {
          number
          title
          url
          headRefName
          state
          isDraft
          mergeable
          reviewDecision
          statusCheckRollup {
            contexts {
              ... on CheckRun {
                conclusion
                status
              }
              ... on StatusContext {
                state
              }
            }
          }
          reviews(last: 50) {
            nodes {
              author {
                login
              }
              state
            }
          }
        }
      GRAPHQL
    end

    query = <<~GRAPHQL
      query {
        repository(owner: "instacart", name: "carrot") {
          #{pr_queries.join("\n")}
        }
      }
    GRAPHQL

    result = `gh api graphql -f query='#{query.gsub("'", "'\\''")}' 2>/dev/null`
    return {} if result.empty?

    data = JSON.parse(result)
    repo_data = data.dig('data', 'repository')
    return {} unless repo_data

    # Convert GraphQL response to hash keyed by PR number
    pr_info_by_number = {}
    pr_numbers.each_with_index do |num, idx|
      pr_data = repo_data["pr#{idx}"]
      next unless pr_data

      # Transform GraphQL response to match gh pr view format
      pr_info_by_number[num] = {
        'number' => pr_data['number'],
        'title' => pr_data['title'],
        'url' => pr_data['url'],
        'headRefName' => pr_data['headRefName'],
        'state' => pr_data['state'],
        'isDraft' => pr_data['isDraft'],
        'mergeable' => pr_data['mergeable'],
        'reviewDecision' => pr_data['reviewDecision'],
        'statusCheckRollup' => pr_data['statusCheckRollup'],
        'reviews' => pr_data.dig('reviews', 'nodes') || []
      }
    end

    pr_info_by_number
  rescue JSON::ParserError, StandardError
    {}
  end

  def refresh_all_status(prs, force: false)
    # Determine which PRs need refreshing
    prs_to_refresh = prs.select { |pr| needs_refresh?(pr, force: force) }

    if prs_to_refresh.empty?
      puts "All PRs recently checked (within last 2 minutes). Use -U to force update." unless force
      return prs
    end

    # Batch fetch all PR info at once
    pr_numbers = prs_to_refresh.map { |pr| pr['number'] }
    fetched_info = batch_fetch_pr_info(pr_numbers)

    # Update each PR with fetched info
    prs_to_refresh.each do |pr|
      info = fetched_info[pr['number']]
      next unless info

      pr['state'] = info['state']
      pr['title'] = info['title']
      pr['checks'] = summarize_checks(info['statusCheckRollup'])
      pr['reviews'] = summarize_reviews(info['reviews'])
      pr['review_decision'] = info['reviewDecision']
      pr['is_draft'] = info['isDraft']
      pr['mergeable'] = info['mergeable']
      pr['last_checked'] = Time.now.iso8601
    end

    prs
  end

  def refresh_status(pr, force: false)
    return pr unless needs_refresh?(pr, force: force)

    info = fetch_pr_info(pr['number'])
    return pr unless info

    pr['state'] = info['state']
    pr['title'] = info['title']
    pr['checks'] = summarize_checks(info['statusCheckRollup'])
    pr['reviews'] = summarize_reviews(info['reviews'])
    pr['review_decision'] = info['reviewDecision']
    pr['is_draft'] = info['isDraft']
    pr['mergeable'] = info['mergeable']
    pr['last_checked'] = Time.now.iso8601
    pr
  end

  def summarize_checks(rollup)
    return nil unless rollup

    contexts = rollup.is_a?(Array) ? rollup : []
    return nil if contexts.empty?

    total = contexts.length
    success = contexts.count { |c| c['conclusion'] == 'SUCCESS' }
    pending = contexts.count { |c| c['status'] == 'PENDING' || c['status'] == 'IN_PROGRESS' }
    failed = contexts.count { |c| c['conclusion'] == 'FAILURE' || c['conclusion'] == 'ERROR' }

    { 'total' => total, 'success' => success, 'pending' => pending, 'failed' => failed }
  end

  def summarize_reviews(reviews)
    return nil unless reviews.is_a?(Array) && !reviews.empty?

    # Get the latest review state per author
    latest_by_author = {}
    reviews.each do |review|
      author = review['author']['login'] rescue nil
      next unless author
      # Only track if it's a meaningful state
      state = review['state']
      next unless %w[APPROVED CHANGES_REQUESTED COMMENTED].include?(state)
      latest_by_author[author] = state
    end

    approved = latest_by_author.values.count { |s| s == 'APPROVED' }
    changes_requested = latest_by_author.values.count { |s| s == 'CHANGES_REQUESTED' }
    commented = latest_by_author.values.count { |s| s == 'COMMENTED' }

    { 'approved' => approved, 'changes_requested' => changes_requested, 'commented' => commented, 'reviewers' => latest_by_author }
  end

  def display_pinned(pr, idx = nil)
    num = idx ? "#{(idx + 1).to_s.rjust(3)}." : ""
    state_icon = case pr['state']
    when 'MERGED' then '[M]'
    when 'CLOSED' then '[X]'
    else pr['is_draft'] ? '[D]' : '[O]'
    end

    checks_str = if pr['checks']
      c = pr['checks']
      if c['failed'] > 0
        " checks:#{c['success']}/#{c['total']} FAIL:#{c['failed']}"
      elsif c['pending'] > 0
        " checks:#{c['success']}/#{c['total']} pending:#{c['pending']}"
      else
        " checks:#{c['success']}/#{c['total']}"
      end
    else
      ""
    end

    reviews_str = if pr['reviews']
      r = pr['reviews']
      parts = []
      parts << "#{r['approved']} approved" if r['approved'] > 0
      parts << "#{r['changes_requested']} changes" if r['changes_requested'] > 0
      parts.empty? ? "" : " | #{parts.join(', ')}"
    else
      ""
    end

    "#{num} #{state_icon} ##{pr['number']} #{pr['title']}#{checks_str}#{reviews_str}".strip
  end

  def display_detailed(pr, idx = nil)
    lines = []
    num = idx ? "#{idx + 1}." : ""

    state_str = case pr['state']
    when 'MERGED' then 'MERGED'
    when 'CLOSED' then 'CLOSED'
    else pr['is_draft'] ? 'DRAFT' : 'OPEN'
    end

    lines << "#{num} ##{pr['number']} - #{pr['title']}"
    lines << "   State: #{state_str}"
    lines << "   Branch: #{pr['headRefName']}" if pr['headRefName']
    lines << "   URL: #{pr['url']}" if pr['url']

    # Checks
    if pr['checks']
      c = pr['checks']
      check_status = if c['failed'] > 0
        "FAILING (#{c['success']}/#{c['total']} passed, #{c['failed']} failed)"
      elsif c['pending'] > 0
        "PENDING (#{c['success']}/#{c['total']} passed, #{c['pending']} pending)"
      else
        "PASSING (#{c['success']}/#{c['total']})"
      end
      lines << "   Checks: #{check_status}"
    else
      lines << "   Checks: (none)"
    end

    # Reviews
    if pr['reviews']
      r = pr['reviews']
      review_parts = []
      review_parts << "#{r['approved']} approved" if r['approved'] > 0
      review_parts << "#{r['changes_requested']} requesting changes" if r['changes_requested'] > 0
      review_parts << "#{r['commented']} commented" if r['commented'] > 0

      if review_parts.any?
        lines << "   Reviews: #{review_parts.join(', ')}"
        if r['reviewers'] && !r['reviewers'].empty?
          r['reviewers'].each do |author, state|
            icon = case state
            when 'APPROVED' then '+'
            when 'CHANGES_REQUESTED' then '-'
            else '?'
            end
            lines << "      #{icon} #{author}: #{state.downcase.gsub('_', ' ')}"
          end
        end
      else
        lines << "   Reviews: (none)"
      end
    else
      lines << "   Reviews: (not fetched)"
    end

    # Mergeable
    if pr['mergeable']
      lines << "   Mergeable: #{pr['mergeable']}"
    end

    lines.join("\n")
  end
end

Hiiro.run(*ARGV, plugins: [Pins]) do
  manager = PRManager.new(self)
  pinned_manager = PinnedPRManager.new

  watch_block = ->(original_pr_number=nil, *watch_args) {
    watch = get_value(:watch)
    fail_fast = get_value(:fail_fast)

    pr_valid = false
    pr_number = nil
    if !original_pr_number.nil? && pin_value = pins.get(original_pr_number)
      pr_valid = true
      pr_number = pin_value
    end

    pr_args = [pr_valid ? pr_number : original_pr_number].compact
    check_args = [*pr_args, *watch_args]

    base_cmd = %w[gh pr checks]
    base_cmd << '--watch' if watch
    base_cmd << '--fail-fast' if fail_fast

    command = [
      *base_cmd,
      *check_args,
    ]

    puts command: command, base_cmd: base_cmd, args: check_args;

    result = system(*command)

    pr_info = JSON.parse(`gh pr view #{pr_args.first} --json url,number,title`)
    pr_url = pr_info['url']
    pr_num = pr_info['number']
    pr_title = pr_info['title']

    if result
      system('say', 'pr good')
      system('terminal-notifier', '-title', 'PR Good', '-message', "##{pr_num}: #{pr_title}", '-open', pr_url)
    else
      system('say', 'pr bad')
      system('terminal-notifier', '-title', 'PR Bad', '-message', "##{pr_num}: #{pr_title}", '-open', pr_url)
    end
  }

  add_subcmd(:check, &watch_block)
  add_subcmd(:watch, watch: true, &watch_block)
  add_subcmd(:fwatch, watch: true, fail_fast: true, &watch_block)

  add_subcmd(:number) { |*args|
    stdout = `gh pr view`

    number = stdout[/number:\s*(\d+)/, 1]

    if number
      print number
    else
      puts stdout
    end
  }

  add_subcmd(:link) { |*args|
    stdout = `gh pr view`

    number = stdout[/number:\s*(\d+)/, 1]

    if number
      print ['https://github.com/instacart/carrot/pull/', number].join
    else
      puts stdout
    end
  }

  add_subcmd(:edit) { system(ENV['EDITOR'] || 'nvim', __FILE__) }
  add_subcmd(:save) { |pr_number=nil| manager.save(pr_number) }
  add_subcmd(:current) { manager.current }
  add_subcmd(:open) { |pr_number=nil| manager.open(pr_number) }
  add_subcmd(:view) { |pr_number=nil| manager.view(pr_number) }

  add_subcmd(:select) do |*args|
    # Get my open PRs
    output = `gh pr list --author @me --state open --json number,title,headRefName 2>/dev/null`.strip

    if output.empty?
      STDERR.puts "No open PRs found"
      next
    end

    prs = JSON.parse(output) rescue []
    if prs.empty?
      STDERR.puts "No open PRs found"
      next
    end

    lines = prs.each_with_object({}) do |pr, h|
      display = "##{pr['number']} [#{pr['headRefName']}] #{pr['title']}"
      h[display] = pr['number'].to_s
    end

    selected = fuzzyfind_from_map(lines)

    if selected
      print selected
    end
  end

  add_subcmd(:copy) do |*args|
    output = `gh pr list --author @me --state open --json number,title,headRefName 2>/dev/null`.strip

    if output.empty?
      STDERR.puts "No open PRs found"
      next
    end

    prs = JSON.parse(output) rescue []
    if prs.empty?
      STDERR.puts "No open PRs found"
      next
    end

    lines = prs.each_with_object({}) do |pr, h|
      display = "##{pr['number']} [#{pr['headRefName']}] #{pr['title']}"
      h[display] = pr['number'].to_s
    end

    selected = fuzzyfind_from_map(lines)

    if selected
      Hiiro::Shell.pipe(selected, 'pbcopy')
      puts "Copied PR ##{selected} to clipboard"
    end
  end

  # === PR Pinning ===

  add_subcmd(:pin) do |ref = nil, *pin_args|
    pr_info = nil

    case ref
    when '-', nil
      if ref == '-'
        # Pin current branch's PR
        pr_info = pinned_manager.fetch_current_branch_pr
        unless pr_info
          puts "No PR found for current branch"
          next
        end
      else
        # Select from my PRs
        my_prs = pinned_manager.fetch_my_prs
        if my_prs.empty?
          puts "No open PRs found"
          next
        end

        lines = my_prs.each_with_object({}) do |pr, h|
          display = "##{pr['number']} [#{pr['headRefName']}] #{pr['title']}"
          h[display] = pr
        end

        pr_info = fuzzyfind_from_map(lines)
        unless pr_info
          puts "No PR selected"
          next
        end
      end
    when /^\d+$/
      # Pin by PR number
      pr_info = pinned_manager.fetch_pr_info(ref)
      unless pr_info
        puts "PR ##{ref} not found"
        next
      end
    else
      puts "Usage: h pr pin [-|PR_NUMBER]"
      puts "  -       Pin current branch's PR"
      puts "  <num>   Pin PR by number"
      puts "  (none)  Select from your open PRs"
      next
    end

    pinned_manager.pin(pr_info)
    puts "Pinned PR ##{pr_info['number']}: #{pr_info['title']}"
  end

  add_subcmd(:unpin) do |ref = nil, *unpin_args|
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs"
      next
    end

    pr_number = nil

    if ref.nil?
      # Select from pinned PRs
      lines = pinned.each_with_index.each_with_object({}) do |(pr, idx), h|
        h[pinned_manager.display_pinned(pr, idx)] = pr['number'].to_s
      end

      pr_number = fuzzyfind_from_map(lines)
      unless pr_number
        puts "No PR selected"
        next
      end
    elsif ref =~ /^\d+$/
      pr_number = ref
    else
      puts "Usage: h pr unpin [PR_NUMBER]"
      next
    end

    if pinned_manager.unpin(pr_number)
      puts "Unpinned PR ##{pr_number}"
    else
      puts "PR ##{pr_number} was not pinned"
    end
  end

  add_subcmd(:pinned) do |*args|
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs"
      next
    end

    puts "Pinned PRs:"
    puts

    pinned.each_with_index do |pr, idx|
      puts pinned_manager.display_pinned(pr, idx)
    end
  end

  add_subcmd(:status) do |*status_args|
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs"
      next
    end

    compact = status_args.include?('-c') || status_args.include?('--compact')
    force = status_args.include?('-U') || status_args.include?('--force-update')

    puts "Refreshing status for #{pinned.length} pinned PR(s)..."
    puts

    pinned_manager.refresh_all_status(pinned, force: force)

    pinned.each_with_index do |pr, idx|
      if compact
        puts pinned_manager.display_pinned(pr, idx)
      else
        puts pinned_manager.display_detailed(pr, idx)
        puts
      end
    end

    pinned_manager.save_pinned(pinned)
    puts "---"
    puts "Status updated at #{Time.now.strftime('%H:%M:%S')}"
  end

  add_subcmd(:update) do |*update_args|
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs to update"
      next
    end

    force = update_args.include?('-U') || update_args.include?('--force-update')

    puts "Updating status for #{pinned.length} PR(s)..."
    pinned_manager.refresh_all_status(pinned, force: force)
    pinned_manager.save_pinned(pinned)
    puts "Done."
  end

  add_subcmd(:green) do |*green_args|
    pinned = pinned_manager.load_pinned
    force = green_args.include?('-U') || green_args.include?('--force-update')

    pinned_manager.refresh_all_status(pinned, force: force)
    pinned_manager.save_pinned(pinned)

    filtered = pinned.select { |pr|
      c = pr['checks']
      c && c['failed'] == 0 && c['pending'] == 0 && c['success'] > 0
    }

    if filtered.empty?
      puts "No PRs with passing checks"
      next
    end

    puts "PRs with passing checks:"
    puts
    filtered.each_with_index { |pr, i| puts pinned_manager.display_pinned(pr, i) }
  end

  add_subcmd(:red) do |*red_args|
    pinned = pinned_manager.load_pinned
    force = red_args.include?('-U') || red_args.include?('--force-update')

    pinned_manager.refresh_all_status(pinned, force: force)
    pinned_manager.save_pinned(pinned)

    filtered = pinned.select { |pr|
      c = pr['checks']
      c && c['failed'] > 0
    }

    if filtered.empty?
      puts "No PRs with failing checks"
      next
    end

    puts "PRs with failing checks:"
    puts
    filtered.each_with_index { |pr, i| puts pinned_manager.display_pinned(pr, i) }
  end

  add_subcmd(:old) do |*old_args|
    pinned = pinned_manager.load_pinned
    force = old_args.include?('-U') || old_args.include?('--force-update')

    pinned_manager.refresh_all_status(pinned, force: force)
    pinned_manager.save_pinned(pinned)

    filtered = pinned.select { |pr| pr['state'] == 'MERGED' }

    if filtered.empty?
      puts "No merged PRs"
      next
    end

    puts "Merged PRs:"
    puts
    filtered.each_with_index { |pr, i| puts pinned_manager.display_pinned(pr, i) }
  end

  add_subcmd(:prune) do |*args|
    # Alias to auto-unpin
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs"
      next
    end

    force = args.include?('-U') || args.include?('--force-update')
    pinned_manager.refresh_all_status(pinned, force: force)

    merged_or_closed = pinned.select { |pr| pr['state'] == 'MERGED' || pr['state'] == 'CLOSED' }

    if merged_or_closed.empty?
      puts "No merged or closed PRs to prune"
      pinned_manager.save_pinned(pinned)
      next
    end

    puts "Pruning #{merged_or_closed.length} merged/closed PR(s):"
    puts

    merged_or_closed.each do |pr|
      puts "  ##{pr['number']}: #{pr['title']} [#{pr['state']}]"
      pinned_manager.unpin(pr['number'])
    end

    puts
    puts "Done. #{pinned_manager.load_pinned.length} PR(s) still tracked."
  end

  add_subcmd(:draft) do |*draft_args|
    pinned = pinned_manager.load_pinned
    force = draft_args.include?('-U') || draft_args.include?('--force-update')

    pinned_manager.refresh_all_status(pinned, force: force)
    pinned_manager.save_pinned(pinned)

    filtered = pinned.select { |pr| pr['is_draft'] == true }

    if filtered.empty?
      puts "No draft PRs"
      next
    end

    puts "Draft PRs:"
    puts
    filtered.each_with_index { |pr, i| puts pinned_manager.display_pinned(pr, i) }
  end

  add_subcmd(:missing) do
    my_prs = pinned_manager.fetch_my_and_assigned_prs
    pinned_numbers = pinned_manager.load_pinned.map { |p| p['number'] }
    missing = my_prs.reject { |pr| pinned_numbers.include?(pr['number']) }

    if missing.empty?
      puts "All your PRs are tracked"
      next
    end

    puts "Untracked PRs (#{missing.count}):"
    puts
    missing.each { |pr| puts "  ##{pr['number']} [#{pr['headRefName']}] #{pr['title']}" }
  end

  add_subcmd(:amissing) do
    my_prs = pinned_manager.fetch_my_and_assigned_prs
    pinned_numbers = pinned_manager.load_pinned.map { |p| p['number'] }
    missing = my_prs.reject { |pr| pinned_numbers.include?(pr['number']) }

    if missing.empty?
      puts "All your PRs are already tracked"
      next
    end

    missing_numbers = missing.map { |pr| pr['number'] }

    tmpfile = Tempfile.new(['missing-prs-', '.yml'])
    lines = ['---']
    missing.each do |pr|
      lines << ''
      lines << "# [#{pr['headRefName']}] #{pr['title']}"
      lines << "# url: #{pr['url']}"
      lines << "- #{pr['number']}"
    end
    tmpfile.write(lines.join("\n"))
    tmpfile.close

    system(ENV['EDITOR'] || 'nvim', tmpfile.path)

    to_add = YAML.safe_load_file(tmpfile.path) || []
    tmpfile.unlink

    added = 0
    to_add.each do |num|
      pr_info = pinned_manager.fetch_pr_info(num)
      next unless pr_info
      pinned_manager.pin(pr_info)
      puts "Tracked: ##{pr_info['number']} #{pr_info['title']}"
      added += 1
    end

    puts
    puts "Added #{added} PR(s) to tracking."
  end

  add_subcmd(:track) do
    pr_info = pinned_manager.fetch_current_branch_pr
    unless pr_info
      puts "No PR for current branch"
      next
    end

    if pinned_manager.pinned?(pr_info['number'])
      puts "Already tracking ##{pr_info['number']}"
      next
    end

    full_info = pinned_manager.fetch_pr_info(pr_info['number'])
    pinned_manager.pin(full_info)
    puts "Now tracking ##{pr_info['number']}: #{pr_info['title']}"
  end

  add_subcmd(:ignore) do |ref = nil|
    # Alias to unpin
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No tracked PRs"
      next
    end

    pr_number = nil

    if ref.nil?
      lines = pinned.each_with_index.each_with_object({}) do |(pr, idx), h|
        h[pinned_manager.display_pinned(pr, idx)] = pr['number'].to_s
      end

      pr_number = fuzzyfind_from_map(lines)
      unless pr_number
        puts "No PR selected"
        next
      end
    elsif ref =~ /^\d+$/
      pr_number = ref
    else
      puts "Usage: h pr ignore [PR_NUMBER]"
      next
    end

    if pinned_manager.unpin(pr_number)
      puts "Stopped tracking PR ##{pr_number}"
    else
      puts "PR ##{pr_number} was not tracked"
    end
  end

  add_subcmd(:rm) do |ref = nil|
    # Alias to ignore/unpin
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No tracked PRs"
      next
    end

    pr_number = nil

    if ref.nil?
      lines = pinned.each_with_index.each_with_object({}) do |(pr, idx), h|
        h[pinned_manager.display_pinned(pr, idx)] = pr['number'].to_s
      end

      pr_number = fuzzyfind_from_map(lines)
      unless pr_number
        puts "No PR selected"
        next
      end
    elsif ref =~ /^\d+$/
      pr_number = ref
    else
      puts "Usage: h pr rm [PR_NUMBER]"
      next
    end

    if pinned_manager.unpin(pr_number)
      puts "Removed PR ##{pr_number} from tracking"
    else
      puts "PR ##{pr_number} was not tracked"
    end
  end

  add_subcmd(:'suggest-unpin') do |*args|
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs"
      next
    end

    # Refresh all statuses first
    force = args.include?('-U') || args.include?('--force-update')
    pinned_manager.refresh_all_status(pinned, force: force)
    pinned_manager.save_pinned(pinned)

    merged = pinned.select { |pr| pr['state'] == 'MERGED' }
    closed = pinned.select { |pr| pr['state'] == 'CLOSED' }

    if merged.empty? && closed.empty?
      puts "No merged or closed PRs to unpin"
      next
    end

    puts "PRs that can be unpinned:"
    puts

    (merged + closed).each_with_index do |pr, idx|
      puts pinned_manager.display_pinned(pr, idx)
    end

    puts
    puts "Run 'h pr auto-unpin' to unpin all merged/closed PRs"
  end

  add_subcmd(:'auto-unpin') do |*args|
    pinned = pinned_manager.load_pinned

    if pinned.empty?
      puts "No pinned PRs"
      next
    end

    # Refresh all statuses first
    force = args.include?('-U') || args.include?('--force-update')
    pinned_manager.refresh_all_status(pinned, force: force)

    merged_or_closed = pinned.select { |pr| pr['state'] == 'MERGED' || pr['state'] == 'CLOSED' }

    if merged_or_closed.empty?
      puts "No merged or closed PRs to unpin"
      pinned_manager.save_pinned(pinned)
      next
    end

    puts "Unpinning #{merged_or_closed.length} merged/closed PR(s):"
    puts

    merged_or_closed.each do |pr|
      puts "  ##{pr['number']}: #{pr['title']} [#{pr['state']}]"
      pinned_manager.unpin(pr['number'])
    end

    puts
    puts "Done. #{pinned_manager.load_pinned.length} PR(s) still pinned."
  end
end
