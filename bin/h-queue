#!/usr/bin/env ruby

require 'hiiro'
require_relative '../lib/hiiro/queue'

Hiiro.run(*ARGV) do
  q = Hiiro::Queue.current

  add_subcmd(:watch) {
    q.queue_dirs # ensure dirs exist
    puts "Watching #{File.join(Hiiro::Queue::DIR, 'pending')} ..."
    puts "Press Ctrl-C to stop"
    loop do
      q.tasks_in(:pending).each { |name| q.launch_task(name) }
      sleep 2
    end
  }

  add_subcmd(:run) { |name = nil|
    if name
      name = name.sub(/\.md$/, '')
      task = q.find_task(name)
      if task.nil?
        puts "Task not found: #{name}"
        next
      end
      if task[:status] != 'pending'
        puts "Task '#{name}' is #{task[:status]}, not pending"
        next
      end
      q.launch_task(name)
    else
      pending = q.tasks_in(:pending)
      if pending.empty?
        puts "No pending tasks"
        next
      end
      pending.each { |n| q.launch_task(n) }
    end
  }

  add_subcmd(:ls) {
    tasks = q.all_tasks
    if tasks.empty?
      puts "No tasks"
      next
    end
    tasks.each do |t|
      puts "%-10s %s" % [t[:status], t[:name]]
    end
  }

  add_subcmd(:list) { |*args|
    # alias for ls
    runners.resolve('ls').handler.call(*args)
  }

  add_subcmd(:status) {
    tasks = q.all_tasks
    if tasks.empty?
      puts "No tasks"
      next
    end
    tasks.each do |t|
      meta = q.meta_for(t[:name], t[:status].to_sym)
      line = "%-10s %s" % [t[:status], t[:name]]
      if meta
        started = meta['started_at']
        if started && t[:status] == 'running'
          elapsed = Time.now - Time.parse(started)
          mins = (elapsed / 60).to_i
          line += "  (#{mins}m elapsed)"
        end
        line += "  [#{meta['tmux_session']}:#{meta['tmux_window']}]" if meta['tmux_session']
        line += "  dir:#{meta['working_dir']}" if meta['working_dir']
      end
      puts line
    end
  }

  add_subcmd(:attach) { |name = nil|
    running = q.tasks_in(:running)
    if running.empty?
      puts "No running tasks"
      next
    end

    if name.nil?
      if running.size == 1
        name = running.first
      else
        name = fuzzyfind(running)
      end
    end

    if name
      exec('tmux', 'select-window', '-t', "#{Hiiro::Queue::TMUX_SESSION}:#{name}")
    end
  }

  add_subcmd(:add) { |*args|
    q.queue_dirs # ensure dirs exist

    if args.empty? && !$stdin.tty?
      content = $stdin.read.strip
      name = q.slugify(content.lines.first.to_s.strip)
    elsif args.any?
      content = args.join(' ')
      name = q.slugify(content)
    else
      require 'tempfile'
      tmpfile = Tempfile.new(['hq-', '.md'])
      tmpfile.close
      editor = ENV['EDITOR'] || 'vim'
      system(editor, tmpfile.path)
      content = File.read(tmpfile.path).strip
      tmpfile.unlink
      if content.empty?
        puts "Aborted (empty file)"
        next
      end
      name = q.slugify(content.lines.first.strip)
    end

    if name.empty?
      puts "Could not generate a task name"
      next
    end

    # Avoid name collisions
    base_name = name
    counter = 1
    while File.exist?(File.join(Hiiro::Queue::DIR, 'pending', "#{name}.md"))
      counter += 1
      name = "#{base_name}-#{counter}"
    end

    path = File.join(Hiiro::Queue::DIR, 'pending', "#{name}.md")
    File.write(path, content + "\n")
    puts "Created: #{path}"
  }

  add_subcmd(:kill) { |name = nil|
    running = q.tasks_in(:running)
    if running.empty?
      puts "No running tasks"
      next
    end

    if name.nil?
      if running.size == 1
        name = running.first
      else
        name = fuzzyfind(running)
      end
    end

    next unless name

    # Kill the tmux window
    system('tmux', 'kill-window', '-t', "#{Hiiro::Queue::TMUX_SESSION}:#{name}")

    # Move files to failed
    dirs = q.queue_dirs
    md = File.join(dirs[:running], "#{name}.md")
    meta_path = File.join(dirs[:running], "#{name}.meta")
    FileUtils.mv(md, File.join(dirs[:failed], "#{name}.md")) if File.exist?(md)
    FileUtils.mv(meta_path, File.join(dirs[:failed], "#{name}.meta")) if File.exist?(meta_path)
    puts "Killed: #{name}"
  }

  add_subcmd(:retry) { |name = nil|
    retryable = q.tasks_in(:failed) + q.tasks_in(:done)
    if retryable.empty?
      puts "No failed/done tasks to retry"
      next
    end

    if name.nil?
      if retryable.size == 1
        name = retryable.first
      else
        name = fuzzyfind(retryable)
      end
    end

    next unless name

    task = q.find_task(name)
    unless task && %w[failed done].include?(task[:status])
      puts "Task '#{name}' is not in failed/done state"
      next
    end

    dirs = q.queue_dirs
    src_dir = dirs[task[:status].to_sym]
    FileUtils.mv(File.join(src_dir, "#{name}.md"), File.join(dirs[:pending], "#{name}.md"))
    meta_path = File.join(src_dir, "#{name}.meta")
    FileUtils.rm_f(meta_path) if File.exist?(meta_path)
    puts "Moved to pending: #{name}"
  }

  add_subcmd(:clean) {
    dirs = q.queue_dirs
    count = 0
    %i[done failed].each do |status|
      Dir.glob(File.join(dirs[status], '*')).each do |f|
        FileUtils.rm_f(f)
        count += 1
      end
    end
    puts "Cleaned #{count} files"
  }

  add_subcmd(:dir) {
    q.queue_dirs # ensure dirs exist
    puts Hiiro::Queue::DIR
  }
end
