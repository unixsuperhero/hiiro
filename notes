
# Principles to use for refactoring

- Separate data from behavior - create domain objects and any relevant value objects


# Goals

- same code to manage tasks/subtasks
  - just scoped differently
  - if scope is `:task` then consider all tasks, if scope is :subtask then only consider the tasks associated with the parent task
- extract data objects
  - so our procedures are human and easy af
- more composable
- separate presentation layer from the data


# features we want

- list tasks/subtasks
- start a new one (wtree/tmux session)
- switch between them
- cd to an app's directory
- stop a task
- use yml files to track things

turn @plugins/tasks.rb into a plugin similar to @plugins/task.rb

but in add_subcommands(hiiro) i want to define 2 subtasks:
1. `:task`
2. `:subtask`

both subcommands should initialize `Tasks.new(hiiro_instance, :task)` or
`Tasks.new(hiiro_instance, :subtask)` if the subtask subcmd was called

then uses the instance of Tasks to either do all the things that it needs to
do... or just use it to get the data it needs, so that it can do the high level
things like running tmux or git worktree commands.
if it doesn't put those things inside Tasks, that would be better, so I can use
these objects in other places like inside @bin/h-link

use the following interface as a guide for how to organize things inside the
new Tasks plugin

# Interface

class Environment
  def self.current  # => Environment - makes new instance
  def all_tasks     # => Task[] - call Task.all and memo cache the result
  def all_sessions  # => Session[] - call TmuxSession.all and memo cache the result
  def all_trees     # => Tree[] - call Tree.all and memo cache the result
  def task          # => Task - move Task.current's behavior into this method, and memo cache the result
  def session       # => Session - move TmuxSession.current here and memo cache the result
  def tree          # => Tree - move Tree.current here and memo cache the result

class Tree
  attr_reader :path, :task, :session

  def self.current  # => Tree - move to Environment#tree
  def self.all      # => Tree[]

class Session
  attr_reader :name, :task

  def self.current  # => Session - move to Environment#session
  def self.all      # => Session[]

class Task
  attr_reader :name, :tree, :session, :parent, :subtasks

  def self.current  # => Task - move to Environment#task
  def self.all      # => Task[]

class App
  attr_reader :name, :path
  def self.current      # => App[]
  def self.all          # => App[]

class Tasks
  attr_reader :hiiro, :scope, :environment

  def tasks                           # => Task[]
  def subtasks(task)                  # => Task[]
  def task_by_name(name)              # => Task
  def task_by_tree(tree_name)         # => Task
  def task_by_session(session_name)   # => Task
  def current_task                    # => Task
  def current_session                 # => Session
  def current_tree                    # => Tree

  def start_task(name, path)          # => Task
  def switch_to_task(task)            # => nil
  def stop_task(task)                 # => nil
  def list(tasks)                     # => nil # print to screen
  def cd_to_task(task)                # => nil
  def cd_to_app(app_name)             # => nil

  class Config
    attr_reader :path




